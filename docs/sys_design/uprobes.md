# Uprobes

## 设计思路

### 函数跟踪

1. 注册阶段

   - 根据传入的地址与探测的用户程序路径，解析指令，获取sp的变化值，与`handler`，`post_handler`等一起存入`uprobes`数据结构中.
   - 将当前地址改为可写并修改指令为`ebreak`.

2. 中断处理阶段

   根据中断地址与进程inode判断当前属于哪个`uprobe`,并判断其属于哪一次中断.剩下同kprobes处理办法.

   - 第一次中断
     1. 执行`handler`.
     2. 保存跟踪函数的返回值，并将其改为ebreak的地址.
     3. 根据解析出的sp值，对堆栈指针进行操作.
     4. 返回到中断指令的下一条指令.
   - 第二次中断
     1. 执行`post_handler`.
     2. 将中断的返回地址改为之前保存的返回值.

### 指令跟踪

1. 注册阶段

   - 根据传入的地址，解析指令，判断是否合法(合法的判断条件同Linux的规则)，将`handler`，`post_handler`等一起存入`kprobes`数据结构中.
   - 如果合法，开辟一块可读可写可执行的用户态空间，将当前地址的指令存放到开辟了的用户态空间中，并在指令后添加ebreak指令.

2. 中断处理阶段

   根据中断地址与用户态进程的路径判断当前属于哪个`uprobe`,并判断其属于哪一次中断.剩下同kprobes处理办法.

   - 第一次中断
     1. 执行`handler`.
     2. 返回到注册阶段开辟出来的地址上.
   - 第二次中断
     1. 执行`post_handler`.
     2. 将中断返回地址改为原地址的下一条指令的地址.

### 执行阶段

获取即将运行的用户态进程，将该进程上已经注册的跟踪点进行操作，添加ebreak等

### 数据结构

- **addr：** 跟踪的地址
- **length：** 指令长度
- **slot_addr：** 用户态插槽的地址
- **addisp：** 栈指针偏移
- **func_ra：** 返回值地址
- **func_ebreak_addr：** 函数中断地址
- **insn_ebreak_addr：** 指令中断地址
- **handler：** 跟踪前回调函数
- **post_handler：** 跟踪后回调函数
- **probe_type：** 探测类型

## 流程

流程基本同[kprobes](./kprobes.md#流程图)