# Linux中的eBPF

- [简介](#简介)
- [eBPF指令集](#ebpf指令集)
  - [寄存器与调用约定](#寄存器与调用约定)
  - [指令编码](#指令编码)
- [eBPF验证器](#ebpf验证器)
- [eBPF helpers](#ebpf_helpers)
- [eBPF maps](#ebpf_maps)

# 简介

eBPF 源于 BPF，本质上是处于内核中的一个高效与灵活的虚类虚拟机组件，以一种安全的方式在许多内核 hook 点执行字节码。BPF 最初的目的是用于高效网络报文过滤，经过重新设计，eBPF 不再局限于网络协议栈，已经成为内核顶级的子系统，演进为一个通用执行引擎。开发者可基于 eBPF 开发性能分析工具、软件定义网络、安全等诸多场景。

## eBPF指令集

### 寄存器与调用约定

eBPF 有10个通用寄存器和一个只读栈帧寄存器，它们均为64位。

eBPF 调用规则定义为：

 - R0：函数调用的返回值和 eBPF 程序的退出值
 - R1 - R5：函数调用的参数
 - R6 - R9：被调用方保存的寄存器，函数调用将保留这些寄存器
 - R10：访问堆栈的只读栈帧指针

R0 - R5 是暂存寄存器，如有必要，eBPF 程序需要在调用之间溢出/填充它们。

### 指令编码

eBPF 有两种指令编码：

 - 基本指令编码，使用 64 位对指令进行编码
 - 宽指令编码，它在基本指令之后附加第二个 64 位即时值 （imm64），总共 128 位。

基本指令编码如下所示：

| 32 位 （MSB） | 16 位 | 4 位     | 4 位       | 8 位 （LSB） |
| ------------- | ----- | -------- | ---------- | ------------ |
| 立即数        | 偏移  | 源寄存器 | 目标寄存器 | 操作码       |

请注意，大多数说明不会使用所有字段。未使用的字段应清除为零。

## eBPF验证器

eBPF计划的安全性分两步确定。

第一步执行 DAG 检查以禁止循环和其他 CFG 验证。特别是，它将检测具有无法访问的指令的程序。（尽管传统的 BPF 检查器允许它们）

第二步从第一个 指令 开始，并下降所有可能的路径。它模拟每个 指令 的执行，并观察寄存器和堆栈的状态变化。

在程序开始时，寄存器R1包含一个指向上下文的指针，其类型为PTR_TO_CTX。如果验证者看到一个执行 R2=R1 的指令，则 R2 现在也具有类型 PTR_TO_CTX并且可以在表达式的右侧使用。如果 R1=PTR_TO_CTX指令 为 R2=R1+R1，则 R2=SCALAR_VALUE，因为添加两个有效指针会使指针无效。（在“安全”模式下，验证程序将拒绝任何类型的指针算术，以确保内核地址不会泄露给非特权用户）

## eBPF_helpers

ebpf的帮助函数，在eBPF程序中，只可调用这些函数

## eBPF_maps

maps是一个不同类型的通用存储方式，用于在内核和用户空间之间共享数据。



更多eBPF信息可查看：[BPF Documentation — The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/bpf/index.html)